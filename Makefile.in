#=========================================================================
# Makefile for Modular Python Build System
#=========================================================================
# This is a simple start to a much more sophisticated Verilog build
# system. For most packages, a developer will not need to make any
# changes to this file except to make sure that the subpkgs make variable
# correctly lists the desired subpackages to include in this package.
# Developers also need to make sure each subpackage makefile fragment
# (e.g., vc.mk) is uptodate with a list of all of the subpackage
# dependencies, Verilog source files, test source files, and program
# source files. The key targets for this Makefile are as follows:
#
#  - default   : build all programs
#  - check     : build and run all unit tests
#  - clean     : remove all generated content
#

#-------------------------------------------------------------------------
# List of subpackages
#-------------------------------------------------------------------------

subpkgs = \
  pymtl \
  pmlib \
  pex_regincr \
  pex_sorter \
  pex_gcd \
  pex_dac \
  plab1_imul \
  plab2_proc \
  plab3_mem \
  plab4_net \

#-------------------------------------------------------------------------
# List of subpackages to install
#-------------------------------------------------------------------------

subpkgs_install = \
  pymtl \
  pmlib \

#-------------------------------------------------------------------------
# Basic setup
#-------------------------------------------------------------------------

# Remove all default implicit rules since they can cause subtle bugs
# and they just make things run slower
.SUFFIXES:
% : %,v
% : RCS/%,v
% : RCS/%
% : s.%
% : SCCS/s.%

# Default is to build the prereqs of the all target (defined at bottom)
default : all
.PHONY : default

project_name := @PACKAGE_TARNAME@
src_dir     = @srcdir@
scripts_dir = $(src_dir)/scripts

# If the version information is not in the configure script, then we
# assume that we are in a working directory. We use the vcs-version.sh
# script in the scripts directory to generate an appropriate version
# string. Currently the way things are setup we have to run this script
# everytime we run make so the script needs to be as fast as possible.

ifeq (@PACKAGE_VERSION@,?)
  project_ver:=$(shell $(scripts_dir)/vcs-version.sh $(src_dir))
else
  project_ver:=@PACKAGE_VERSION@
endif

#-------------------------------------------------------------------------
# Installation directory setup
#-------------------------------------------------------------------------

prefix       := @prefix@
enable_stow  := @enable_stow@

ifeq ($(enable_stow),yes)
  stow_pkg_dir := $(prefix)/pkgs
  DESTDIR ?= $(stow_pkg_dir)/$(project_name)-$(project_ver)
else
  DESTDIR ?= $(prefix)
endif

# We need to change this to set the python version number from configure
# bsaed on what version of python we are using by default.

install_libs_dir := $(DESTDIR)/lib/python2.7/site-packages
install_exes_dir := $(DESTDIR)/bin

#-------------------------------------------------------------------------
# Programs
#-------------------------------------------------------------------------

PYTHON = @python@
PYTEST = @pytest@

# Installation

MKINSTALLDIRS := $(scripts_dir)/mk-install-dirs.sh
INSTALL       := @INSTALL@
INSTALL_HDR   := $(INSTALL) -m 444
INSTALL_LIB   := $(INSTALL) -m 644
INSTALL_EXE   := $(INSTALL) -m 555
STOW          := @stow@

#-------------------------------------------------------------------------
# Makefile fragments from subpackages
#-------------------------------------------------------------------------

subpkgs_mk := \
  $(join $(addprefix $(src_dir)/, $(subpkgs)), \
         $(patsubst %, /%.mk, $(subpkgs)))

-include $(subpkgs_mk)
VPATH := $(addprefix $(src_dir)/, $(subpkgs))

#-------------------------------------------------------------------------
# Template for per subpackage rules
#-------------------------------------------------------------------------

# Helper template for collecting sources from subpackage dependencies

define subpkg_template_collect_deps
$(1)_deps_srcs      += $$($(2)_srcs)
$(1)_deps_test_srcs += $$($(2)_test_srcs)
endef

# Main subpackage template

define subpkg_template

# Subpackage subdirectory

$(2)_dir := $$(addprefix $(src_dir)/, $(1))

# Subpackage make fragment

$(2)_mk := $(2).mk

# Subpackage dependencies

$$(foreach dep,$$($(2)_deps), \
  $$(eval $$(call subpkg_template_collect_deps,$(2),$$(dep))))

# Run unit tests

$(2)_test_outs := $(1)-test.out
$(2)_test_srcs_wdir := $$(addprefix $(src_dir)/$(2)/, $$($(2)_test_srcs))

$$($(2)_test_outs) : %.out : $$($(2)_srcs) $$($(2)_test_srcs) $$($(2)_deps_srcs) $$($(2)_deps_test_srcs) $$($(2)_mk)
	-$(PYTEST) --tb=no --resultlog=$$@ $$($(2)_test_srcs_wdir)

$(2)_junk += $$($(2)_test_outs)

# Build programs - we create a wrapper shell script which sets the
# PYTHONPATH appropriately to be able to run python programs that are in
# the modules from the build directory.

$(2)_prog_exes      := $$(addprefix ., $$($(2)_prog_srcs))
$(2)_prog_exes_real := $$(addprefix ./, $$($(2)_prog_srcs))

$$($(2)_prog_exes) : .% : %
	touch $$@
	echo "#!/bin/sh" > $$*
	echo "env PYTHONPATH=\"$(src_dir):\$$$${PYTHONPATH}\" $(src_dir)/$(2)/$$* \"\$$$$@\"" >> $$*
	chmod a+x $$*

$(2)_junk += $$($(2)_prog_exes) $$($(2)_prog_exes_real)

# Install subpackage python library and programs if the subpackage is on
# the subpkg_install list

ifneq ($$(filter $(1),$(subpkgs_install)),)

# Install subproject python library

$(2)_install_srcs_wdir := \
  $$(addprefix $(src_dir)/$(1)/, $$($(2)_srcs)) \
  $$(addprefix $(src_dir)/$(1)/, $$($(2)_test_srcs)) \
  $(src_dir)/$(1)/__init__.py \

install-libs-$(1) : $$($(2)_srcs) $$($(2)_test_srcs)
	$(MKINSTALLDIRS) $(install_libs_dir)/$(1)
	for file in $$($(2)_install_srcs_wdir); do \
    $(INSTALL_HDR) $$$$file $(install_libs_dir)/$(1); \
  done

install-libs : install-libs-$(1)
.PHONY : install-libs-$(1)

# Install subproject programs

$(2)_prog_srcs_wdir := \
  $$(addprefix $$(src_dir)/$(1)/, $$($(2)_prog_srcs)) \

install-exes-$(1) : $$($(2)_prog_srcs)
	$(MKINSTALLDIRS) $(install_exes_dir)
	for file in $$($(2)_prog_srcs_wdir); do \
    $(INSTALL_EXE) $$$$file $(install_exes_dir); \
  done

install-exes : install-exes-$(1)
.PHONY : install-exes-$(1)

endif

# Other subpkg specific targets

all-$(1) : $$($(2)_prog_exes)

check-$(1) : $$($(2)_test_outs) $(utst_exe)
	$(scripts_dir)/check-summary --verbose $$($(2)_test_outs)

install-$(1) : install-libs-$(1) install-exes-$(1)

clean-$(1) :
	rm -rf $$($(2)_junk)

.PHONY : all-$(1) check-$(1) clean-$(1)

# Update running variables

exes += $$($(2)_prog_exes)
outs += $$($(2)_test_outs)
junk += $$($(2)_junk)

endef

# Call template for each subpackage

$(foreach subpkg,$(subpkgs), \
  $(eval $(call subpkg_template,$(subst _,-,$(subpkg)),$(subpkg))))

#-------------------------------------------------------------------------
# Check
#-------------------------------------------------------------------------

check : $(outs)
	$(scripts_dir)/check-summary $(outs)

.PHONY : check

#-------------------------------------------------------------------------
# Installation
#-------------------------------------------------------------------------

install : install-libs install-exes
ifeq ($(enable_stow),yes)
	$(MKINSTALLDIRS) $(stow_pkg_dir)
	cd $(stow_pkg_dir) && \
    $(STOW) --delete $(project_name)-* && \
    $(STOW) $(project_name)-$(project_ver)
endif

.PHONY : install install-libs install_exes

#-------------------------------------------------------------------------
# Regenerate configure information
#-------------------------------------------------------------------------

configure_prereq = \
  $(src_dir)/configure.ac \
  $(src_dir)/aclocal.m4 \

$(src_dir)/configure : $(configure_prereq)
	cd $(src_dir) && autoconf

config.status : $(src_dir)/configure
	./config.status --recheck

makefile_prereq = \
  config.status \
  $(src_dir)/Makefile.in \

Makefile : $(makefile_prereq)
	./config.status

dist_junk += \
  config.status Makefile config.log \

#-------------------------------------------------------------------------
# Python vpath wrapper
#-------------------------------------------------------------------------
# We create a wrapper shell script which sets the PYTHONPATH
# appropriately to be able to use the subpackages that are in this
# package from the build directory.

python-vpath :
	echo "#!/bin/sh" > $@
	echo "env PYTHONPATH=\"$(src_dir):\$${PYTHONPATH}\" python \"\$$@\"" >> $@
	chmod a+x $@

junk += python-vpath

#-------------------------------------------------------------------------
# Default
#-------------------------------------------------------------------------

all : $(exes)
.PHONY : all

#-------------------------------------------------------------------------
# Makefile debugging
#-------------------------------------------------------------------------
# This handy rule will display the contents of any make variable by
# using the target debug-<varname>. So for example, make debug-junk will
# display the contents of the junk variable.

debug-% :
	@echo $* = $($*)

#-------------------------------------------------------------------------
# Clean up junk
#-------------------------------------------------------------------------

clean :
	rm -rf *~ \#* *.v *.vcd *.stats a.out $(junk)

clean-src :
	find $(src_dir) -name "*.pyc" | xargs rm
	find $(src_dir) -name "__pycache__" | xargs rmdir
	find $(src_dir) -name ".DS_Store" | xargs rm

.PHONY : clean

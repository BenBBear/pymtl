#!/usr/bin/env python
#=========================================================================
# check-summary [options] <test1_out> <test2_out> ...
#=========================================================================
#
#  -h --help     Display this message
#  -v --verbose  Verbose mode
#
# Create a summary of the py.test results.
#
# Author : Christopher Batten
# Date   : August 30, 2012
#

import argparse
import sys
import re

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )
  p.add_argument( "-v", "--verbose", action="store_true" )
  p.add_argument( "-h", "--help",    action="store_true" )
  p.add_argument( "test_outs", nargs="+" )
  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#-------------------------------------------------------------------------
# print_passfail
#-------------------------------------------------------------------------------

def print_passfail( prefix, num_passed, num_failed, msg ):

  if num_failed > 0:
    print prefix, "[ FAILED ] ",
  else:
    print prefix, "[ passed ] ",

  print "P:{:3} F:{:3}  {}".format( num_passed, num_failed, msg )

#-------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

def main():
  opts = parse_cmdline()

  if not opts.verbose:
    print ""

  # Iterate over the subpackages

  subpkg_pattern = re.compile(r'^(.*)_test.out$')
  failed_pattern = re.compile(r'^F .*$')
  passed_pattern = re.compile(r'^\. .*$')
  suite_case_pattern = re.compile(r'^. (([^:]*)::.*)$')
  suite_pattern = re.compile(r'^. (.*)$')

  total_num_subpkg = len(opts.test_outs)
  total_num_passed = 0
  total_num_failed = 0
  total_num_suites = 0

  for test_out in opts.test_outs:

    # Get the name of the subpackage

    match = subpkg_pattern.match(test_out)
    subpkg = match.group(1)

    # Scan through this subpackages test output file

    subpkg_num_passed = 0
    subpkg_num_failed = 0
    subpkg_failing_cases = []

    suites              = []
    suite_num_passed    = {}
    suite_num_failed    = {}
    suite_failing_cases = {}

    for line in open(test_out):

      # Determine if this line contains a test case result

      match_passed = passed_pattern.match(line)
      match_failed = failed_pattern.match(line)

      # Update subpkg information appropriately

      if match_passed or match_failed:

        match_suite_case = suite_case_pattern.match(line)
        if not match_suite_case:
          match_suite = suite_pattern.match(line)
          suite = match_suite.group(1)
          case  = suite + " error processing test suite"
        else:
          suite = match_suite_case.group(2)
          case  = match_suite_case.group(1)

        if match_passed:
          suite_num_passed[suite] = suite_num_passed.get( suite, 0 ) + 1
          subpkg_num_passed += 1

        else:
          suite_num_failed[suite] = suite_num_failed.get( suite, 0 ) + 1
          subpkg_num_failed += 1

          # Also update our list of failing test cases

          if not suite_failing_cases.has_key( suite ):
            suite_failing_cases[suite] = []

          suite_failing_cases[suite].append( case )

      if match_passed or match_failed:
        if len(suites) == 0 or suites[-1] != suite:
          suites.append(suite)

    # Update running totals across suites

    for suite,failing_cases in suite_failing_cases.iteritems():
      for failing_case in failing_cases:
        subpkg_failing_cases.append( failing_case )

    # Update running totals across all packages

    total_num_passed += subpkg_num_passed
    total_num_failed += subpkg_num_failed
    total_num_suites += len(suites)

    # Print non-verbose summary for this subpackage

    if not opts.verbose:
      print_passfail( "", subpkg_num_passed, subpkg_num_failed, subpkg )

      for failing_case in subpkg_failing_cases:
        print "   ", failing_case

    # Print verbose summary for this subpackage

    if opts.verbose:

      print ""
      print " *", subpkg, "Unit Tests"

      for suite in suites:
        print_passfail( "   ", suite_num_passed.get( suite, 0 ),
                        suite_num_failed.get( suite, 0 ), suite )

        for failing_case in suite_failing_cases.get( suite, [] ):
          print "      ", failing_case

  # Print out summary for entire package

  print ""
  print " Test Summary:"
  print "  - Number of subprojects       : {:>3}".format( total_num_subpkg )
  print "  - Number of test suites       : {:>3}".format( total_num_suites )
  print "  - Number of test cases passed : {:>3}".format( total_num_passed )
  print "  - Number of test cases failed : {:>3}".format( total_num_failed )

  print ""

main()


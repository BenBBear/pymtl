#!/usr/bin/env pypy
#=========================================================================
# pex-dac-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#  -v --verbose        Verbose mode
#
#  --impl <impl>       Choose model implementation
#                       torus   : torus with greedy routing
#                       ring    : ring  with greedy routing
#
#  --pattern <pattern> Traffic pattern (default urandom)
#                       tornado  : tornado traffic pattern
#                       urandom  : uniform random traffic pattern
#
#  --step <step-size>  Injection step size value (default 5)
#                       use 5 or 3 for tornado traffic
#                       use 10 for uniform random traffic
#
#  --dump-vcd          Dump vcd to dump.vcd
#  --dump-vcd <fname>  Dump vcd to given file name <fname>
#
#  --stats             Dump stats standard out
#  --stats <fname>     Dump stats to given file name <fname>
#
# Network Simulation Driver. Choose a traffic pattern and injection
# rate step size to generate latency-bandwidth plots.
#
# Author : Shreesha Srinath 
# Date   : November 16, 2012

import argparse
import sys
import re

from math import ceil, log, sqrt

import random
from   random import randint

from   pymtl import *
import pmlib

from pmlib.net_msgs import NetMsgParams

from Ring  import Ring
from Torus import Torus

# Fix the random seed so results are reproducible
random.seed(0xdeadbeef)

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-v", "--verbose", action="store_true" )
  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional command line arguments for the simulator

  p.add_argument( "--impl",
    choices=["torus","ring"] )

  p.add_argument( "--pattern", default="urandom",
    choices=["tornado","urandom"] )

  p.add_argument( "--step", nargs='?',
                  default=10, const=5, type=int )

  p.add_argument( "--dump-vcd", nargs='?',
                  default=False, const="dump.vcd" )

  p.add_argument( "--stats",    nargs='?', default=False, const="-" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#--------------------------------------------------------------------------
# Global Constants
#--------------------------------------------------------------------------

NUM_ROUTERS         = 16
NUM_MESSAGES        = 16
PAYLOAD_NBITS       = 22
NUM_ENTRIES         = 8

NUM_WARMUP_CYCLES   = 8192
NUM_MEASURE_PACKETS = 2
INVALID_TIMESTAMP   = 0 

#--------------------------------------------------------------------------
# simulate
#--------------------------------------------------------------------------

def simulate( ModelType, injection_rate, route_compute, dump_vcd, verbose ):

  # Simulation Variables 

  max_queue           = 0
  observed_thput      = 0
  average_latency     = 0
  packets_generated   = 0
  packets_received    = 0
  total_received      = 0
  total_latency       = 0
  drain_cycles        = 10000
  sim_done            = False

  # Network Parameters

  netmsg_params= NetMsgParams( NUM_ROUTERS, NUM_MESSAGES, PAYLOAD_NBITS )

  # Syntax helper

  def mk_net_msg( dest, src, seq_num, payload ):
    return netmsg_params.mk_msg( dest, src, seq_num, payload )

  # Instantiate and elaborate a ring network 

  model = ModelType( NUM_ROUTERS, NUM_MESSAGES, PAYLOAD_NBITS, NUM_ENTRIES )
  model.elaborate() 

  # Source Queues - Modeled as Bypass Queues

  src = [ [] for x in xrange( NUM_ROUTERS ) ]

  # Create a simulator using the simulation tool

  sim = SimulationTool( model )

  # Turn on vcd dumping

  if dump_vcd:
    sim.dump_vcd(opts.dump_vcd)

  # Reset the simulator

  sim.reset()

  # Run the simulation

  for i in xrange( NUM_ROUTERS ):
    model.out_rdy[i].value = 1

  while not sim_done:
    for i in xrange( NUM_ROUTERS ):

      # Generate packet

      if ( randint( 0, 100 ) < injection_rate ):

        # traffic pattern based dest selection

        dest = route_compute( i )
     
        # inject packet past the warmup period
    
        if (    ( sim.num_cycles  > NUM_WARMUP_CYCLES   )
            and ( packets_generated < NUM_MEASURE_PACKETS ) ):
          src[i].append( mk_net_msg( dest, i, 
                                     0, sim.num_cycles ) )
          packets_generated += 1
    
        # packet injection during warmup or drain phases
    
        else:
          src[i].append( mk_net_msg( dest, i, 
                                     0, INVALID_TIMESTAMP ) )

        # max source queue length recording
      
        if len( src[i] ) > max_queue:
          max_queue = len( src[i] )
      
      # Inject from source queue

      if ( len( src[i] ) > 0 ):
        model.in_msg[i].value = src[i][0]
        model.in_val[i].value = 1
      else: 
        model.in_val[i].value = 0

      # Receive a packet

      if ( model.out_val[i].value == 1 ):
        timestamp = \
          model.out_msg[i].value[ netmsg_params.payload_slice ]
   
        # collect data for measurement packets
       
        if sim.num_cycles  > NUM_WARMUP_CYCLES:
          total_received += 1

        if ( timestamp != INVALID_TIMESTAMP ):
          total_latency    += ( sim.num_cycles - timestamp.uint )
          packets_received += 1
          average_latency = total_latency / float( packets_received )

      # Check if finished - drain phase

      if ( sim.num_cycles - drain_cycles ) > drain_cycles:
        average_latency = total_latency / float( packets_received )
        observed_thput  = ( total_received / float( drain_cycles ) ) / float( NUM_ROUTERS ) 
        sim_done = True
        break

      # Pop the source queue
  
      if ( model.in_rdy[i].value == 1 ) and ( len( src[i] ) > 0 ):
        src[i].pop(0)

    # advance simulation

    sim.cycle()

    # print line trace if enables

    if verbose:
      sim.print_line_trace()

  # return the calculated average_latency and count of packets received   

  return [ observed_thput, average_latency, packets_received, max_queue ]

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

def tornado( node ):
  num_routers_1D = int( sqrt( NUM_ROUTERS ) )
  x = ( (ndoe%num_routers_1D) + int( num_routers_1D/2 ) - 1 ) % num_routers_1D
  y = ( (node/num_routers_1D) + int( num_routers_1D/2 ) - 1 ) % num_routers_1D
  dest = x + num_routers_1D * y
  return dest

def urandom( node ): 
  return randint( 0, NUM_ROUTERS-1 )

def main():
  opts = parse_cmdline()

  # Determine which model to use in the simulator

  impl_dict = {
    'ring'  : Ring,
    'torus' : Torus,
  }

  # Determine which pattern to use and create the pattern

  pattern_dict = {
    'tornado' : tornado,
    'urandom' : urandom,
  }

  # injection sweep step size

  step = opts.step

  # Handle stats, redirect output to standard out or a file

  if opts.stats:
    os = sys.stdout
    if opts.stats != "-":
      os = open( opts.stats, "w" )

  # Network Simulation Sweeps

  for i in xrange( step, 105, step ):
    results = simulate( impl_dict[ opts.impl ],           # model type
                        i,                                # injection rate
                        pattern_dict[ opts.pattern ],     # traffic pattern
                        opts.dump_vcd,                    # dump_vcd
                        opts.verbose )                    # verbose

    # Handle stats if enabled

    if opts.stats:
      print >> os, "{:>2d} {} {} {} {}".format( i, results[0], results[1],  
                                          results[2], results[3] )

main()

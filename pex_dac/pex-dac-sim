#!/usr/bin/env python
#=========================================================================
# pex-dac-sim [options]
#=========================================================================
#
#  -h --help           Display this message
#  -v --verbose        Verbose mode
#
#  --impl <impl>       Choose model implementation
#                       torus4  : torus with greedy routing
#                       torus8  : torus with greedy routing
#                       ring    : ring  with greedy routing
#
#  --pattern <pattern> Traffic pattern (default urandom)
#                       tornado  : tornado traffic pattern
#                       urandom  : uniform random traffic pattern
#
#  --inj               Injection rate
#
#  --dump-vcd          Dump vcd to dump.vcd
#  --dump-vcd <fname>  Dump vcd to given file name <fname>
#
#  --stats             Dump stats standard out
#  --stats <fname>     Dump stats to given file name <fname>
#
# Network Simulation Driver. Choose a traffic pattern and injection
# rate step size to generate latency-bandwidth plots.
#
# Author : Shreesha Srinath
# Date   : November 16, 2012

import argparse
import sys
import re

from math import ceil, log, sqrt

import random
from   random import randint

from   pymtl import *
import pmlib

from pmlib.net_msgs import NetMsgParams
from pmlib.adapters import ValRdyToValCredit, ValCreditToValRdy

from WRing4    import Ring4
from WTorus4x4 import Torus4x4
from WTorus8x8 import Torus8x8

# Fix the random seed so results are reproducible
random.seed(0xdeadbeef)

#-------------------------------------------------------------------------
# Command line processing
#-------------------------------------------------------------------------

class ArgumentParserWithCustomError(argparse.ArgumentParser):
  def error( self, msg = "" ):
    if ( msg ): print("\n ERROR: %s" % msg)
    print("")
    file = open( sys.argv[0] )
    for ( lineno, line ) in enumerate( file ):
      if ( line[0] != '#' ): sys.exit(msg != "")
      if ( (lineno == 2) or (lineno >= 4) ): print( line[1:].rstrip("\n") )

def parse_cmdline():
  p = ArgumentParserWithCustomError( add_help=False )

  # Standard command line arguments

  p.add_argument( "-v", "--verbose", action="store_true" )
  p.add_argument( "-h", "--help",    action="store_true" )

  # Additional command line arguments for the simulator

  p.add_argument( "--impl",
    choices=["torus4","torus8","ring"] )

  p.add_argument( "--pattern", default="urandom",
    choices=["tornado","urandom"] )

  p.add_argument( "--inj", type=int )

  p.add_argument( "--dump-vcd", nargs='?',
                  default=False, const="dump.vcd" )

  p.add_argument( "--stats",    nargs='?', default=False, const="-" )

  opts = p.parse_args()
  if opts.help: p.error()
  return opts

#--------------------------------------------------------------------------
# Global Constants
#--------------------------------------------------------------------------

NUM_ROUTERS         = 16
NUM_MESSAGES        = 16
PAYLOAD_NBITS       = 22
NUM_ENTRIES         = 8

NUM_WARMUP_CYCLES   = 8192
NUM_MEASURE_PACKETS = 256
INVALID_TIMESTAMP   = 0

#--------------------------------------------------------------------------
# simulate
#--------------------------------------------------------------------------

class SimHarness (Model):

  def __init__( s, ModelType, num_routers, num_entries, netmsg_params ):

    # Local Constants

    s.num_routers = num_routers

    # Instantiate Models

    s.network = ModelType( )
    s.v2c     = [ ValRdyToValCredit( netmsg_params.nbits, num_entries )
                  for x in xrange( num_routers ) ]

    s.c2v     = [ ValCreditToValRdy( netmsg_params.nbits, num_entries )
                  for x in xrange( num_routers ) ]

    # connect

    for i in xrange( s.num_routers ):

      connect( s.v2c[i].to_msg,        s.network.in_msg[i]    )
      connect( s.v2c[i].to_val,        s.network.in_val[i]    )
      connect( s.v2c[i].to_credit,     s.network.in_credit[i] )

      connect( s.network.out_msg[i],     s.c2v[i].from_msg    )
      connect( s.network.out_val[i],     s.c2v[i].from_val    )
      connect( s.network.out_credit[i],  s.c2v[i].from_credit )


def simulate( ModelType, injection_rate, route_compute, dump_vcd, verbose ):

  # Simulation Variables

  max_queue           = 0
  observed_thput      = 0
  average_latency     = 0
  packets_generated   = 0
  packets_received    = 0
  total_received      = 0
  total_latency       = 0
  drain_cycles        = 10000
  sim_done            = False

  # Network Parameters

  netmsg_params= NetMsgParams( NUM_ROUTERS, NUM_MESSAGES, PAYLOAD_NBITS )

  # Syntax helper

  def mk_net_msg( dest, src, seq_num, payload ):
    return netmsg_params.mk_msg( dest, src, seq_num, payload )

  # Instantiate and elaborate a ring network

  model = SimHarness( ModelType, NUM_ROUTERS, NUM_ENTRIES, netmsg_params )
  model.elaborate()

  # Source Queues - Modeled as Bypass Queues

  src = [ [] for x in xrange( NUM_ROUTERS ) ]

  # Create a simulator using the simulation tool

  sim = SimulationTool( model )

  # Turn on vcd dumping

  if dump_vcd:
    sim.dump_vcd(dump_vcd)

  # Reset the simulator

  sim.reset()

  # Run the simulation

  for i in xrange( NUM_ROUTERS ):
    model.c2v[i].to_rdy.value = 1

  while not sim_done:
    for i in xrange( NUM_ROUTERS ):

      # Generate packet

      if ( randint( 0, 100 ) < injection_rate ):

        # traffic pattern based dest selection

        dest = route_compute( i )

        # inject packet past the warmup period

        if (    ( sim.num_cycles  > NUM_WARMUP_CYCLES   )
            and ( packets_generated < NUM_MEASURE_PACKETS ) ):
          src[i].append( mk_net_msg( dest, i,
                                     0, sim.num_cycles ) )
          packets_generated += 1

        # packet injection during warmup or drain phases

        else:
          src[i].append( mk_net_msg( dest, i,
                                     0, INVALID_TIMESTAMP ) )

        # max source queue length recording

        if len( src[i] ) > max_queue:
          max_queue = len( src[i] )

      # Inject from source queue

      if ( len( src[i] ) > 0 ):
        model.v2c[i].from_msg.value = src[i][0]
        model.v2c[i].from_val.value = 1
      else:
        model.v2c[i].from_val.value = 0

      # Receive a packet

      if ( model.c2v[i].to_val.value == 1 ):
        timestamp = \
          model.c2v[i].to_msg.value[ netmsg_params.payload_slice ]

        # collect data for measurement packets

        if sim.num_cycles  > NUM_WARMUP_CYCLES:
          total_received += 1

        if ( timestamp != INVALID_TIMESTAMP ):
          total_latency    += ( sim.num_cycles - timestamp.uint )
          packets_received += 1

      # Check if finished - drain phase

      if ( sim.num_cycles - NUM_WARMUP_CYCLES ) > drain_cycles:
        average_latency = total_latency / float( packets_received )
        observed_thput  = ( total_received / float( drain_cycles ) ) / float( NUM_ROUTERS )
        sim_done = True
        break

      # Pop the source queue

      if ( model.v2c[i].from_rdy.value == 1 ) and ( len( src[i] ) > 0 ):
        src[i].pop(0)

    # advance simulation

    sim.cycle()

    # print line trace if enables

    if verbose:
      sim.print_line_trace()

  # return the calculated average_latency and count of packets received

  return [ observed_thput, total_received, average_latency, packets_received, max_queue, sim.num_cycles ]

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------

def tornado( node ):
  num_routers_1D = int( sqrt( NUM_ROUTERS ) )
  x = ( (node%num_routers_1D) + int( num_routers_1D/2 ) - 1 ) % num_routers_1D
  y = ( (node/num_routers_1D) + int( num_routers_1D/2 ) - 1 ) % num_routers_1D
  dest = x + num_routers_1D * y
  return dest

def urandom( node ):
  return randint( 0, NUM_ROUTERS-1 )

def main():
  opts = parse_cmdline()

  # Determine which model to use in the simulator

  impl_dict = {
    'ring'   : Ring4,
    'torus4' : Torus4x4,
    'torus8' : Torus8x8,
  }

  # set the global network parameters

  global NUM_ROUTERS
  global PAYLOAD_NBITS

  if   opts.impl == 'torus4':
    NUM_ROUTERS   = 16
    PAYLOAD_NBITS = 22
  elif opts.impl == 'torus8':
    NUM_ROUTERS   = 64
    PAYLOAD_NBITS = 18
  elif opts.impl == 'ring':
    NUM_ROUTERS   = 4
    PAYLOAD_NBITS = 26

  # Determine which pattern to use and create the pattern

  pattern_dict = {
    'tornado' : tornado,
    'urandom' : urandom,
  }

  # injection sweep step size

  i = opts.inj

  # Handle stats, redirect output to standard out or a file

  if opts.stats:
    os = sys.stdout
    if opts.stats != "-":
      os = open( opts.stats, "w" )

  # Network Simulation Sweeps

  results = simulate( impl_dict[ opts.impl ],           # model type
                      i,                                # injection rate
                      pattern_dict[ opts.pattern ],     # traffic pattern
                      opts.dump_vcd,                    # dump_vcd
                      opts.verbose )                    # verbose

  # Handle stats if enabled

  if opts.stats:
    print >> os, "{:>2d} {} {} {} {} {} {}".format( i, results[0], results[1],
                                    results[2], results[3], results[4], results[5] )

main()
